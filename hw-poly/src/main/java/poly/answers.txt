## CSE 331 hw-poly Questions
## Part 0
###########################################################################

1. Multiplication Pseudocode
r = p*q:

    {inv: r = q0 * p0 + q0 * p1 + ... + q0*p(i-1) + q1*p0 + ... q(j-1) * p0}
    foreach term tq in q:
        foreach term tp in p:
            add tq * tp to r

2. Division Pseudocode
r = p / q:
    dividend = p;
    divisor = q[0];
    start = index of first nonzero coeff. in dividend (else -1)
    {inv: r = dividend[0] / divisor +...+ dividend[start] / divisor}
    while(dividend[start] degree >= divisor degree) {
        curr = dividend[start] / divisor
        add curr to r
        subtract curr * q from dividend
        start = index of first nonzero coeff. in dividend (else -1)
    }

3. Division Example: (x3+x-1) / (x+1) = x2-x+2
    dividend = x3+x-1
    divisor = x+1
    start = 0
    while(dividend[start] degree >= divisor degree && start != -1) {
        first iteration:
            curr = x3 / x = x2
            r = x2
            subtract curr * q from dividend
            dividend = {0, -1x2, 1, -1}
            start = 1
        second iteration:
            curr = -1x2 / x = -1x
            r = x2 - x
            subtract curr * q from dividend
            dividend = {0, 0, 2x, 0}
            start = 2
        third iteration:
            curr = 2x / x = 2
            r = x2 - x + 2
            subtract curr * q from dividend
            dividend = {0, 0, 0, -2}
            start = -1;

    }
    r = x2 - x + 2




## Part 1
###########################################################################

1. Weakened Rep Invariant
- constructor would set n and d directly to numer and denom fields instead of reducing the numbers
- checkRep would not need to include a check for reduced form
- equals would not work if rational number is not reduced, must reduce both numbers to be compared
- toString would need to reduce the number first before returning as string


2. Alternate add, sub, mul, div
    @spec.effects does not mention that the object fields themselves have changed in
    returning itself


3. Constructor checkReps
No method of RatNum can directly change the fields in the RatNum object, so
the only time checkReps is necessary is after the fields are changed in the constructor.



## Part 2
###########################################################################

1. Calls to checkRep in RatTerm
I called checkRep at the end of the constructor in RatTerm as none of methods change
the fields of the object and the fields themselves are immutable


2. Weakened Rep Invariant
- add() and sub() would check what term was zero before adding the other instead of
checking its exponent, this could make the code clearer to read without the conditionals
- the constructor would simply set this.expt to the given e instead of checking for a
zero exponent value
- toString would need additional checks for 0 valued exponent, otherwise cases such
as 0x of 0x^3 could occur, which is not allowed by @return


3. Alternate Rep Invariant
- the constructor would change to force the expt to be 0 if the coefficient was
NaN. Other than that, the other methods do not make use of a RatNum that has a
coeff. of NaN, so the expt is uneffected.


4. Preferred Invariants
Coeff.equals(RatNum.ZERO) â‡’ expt = 0 was a useful invariant because of the case
where 0^0 would be undefined if x happened to be 0, i.e. a RatTerm of 0x^0



## Part 3
###########################################################################

1. Calls to checkRep in RatPoly



2. Alternate Representation



