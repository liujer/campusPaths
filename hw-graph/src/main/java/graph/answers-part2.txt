## CSE 331 hw-graph Part 2 Questions

NOTE: This file is used as part of hw-graph-part2, and is not due as part of the hw-graph-part1
submission. You may leave it blank for hw-graph-part1.

## Section 1
###########################################################################

A few examples of possible Graph representations:

    A: A collection of edges.
    B: An adjacency list, in which each node is associated with a list of its outgoing edges.
    C: An adjacency matrix, which explicitly represents, for every pair ⟨A,B⟩ of edges, whether there is a link from A to B, and how many.

1. In two or three sentences, explain an advantage and a disadvantage of each of the
representations listed above (for example, in terms of runtime complexity, space
complexity, or ease of implementation).

A: Adding edges would occur in O(1) and looking up edges would occur in O(|V|) (v = number of vertices) runtime, which is
slow in this case.
B: In an adjacency list, looking up edges and adding edges would occur in O(1). A disadvantage of
the adjaceny list is that removing edges would occur in O(|V|) (v = number of vertices).
C: In an adjacency matrix, adding a vertex occurs in O(|V|^2), which is extremely slow. However, adding
edges would occur in O(1).


2. In two to three sentences, describe the representation you chose and explain why you
chose it. If you chose to use a different representation than one of the three we described
above, be sure to list its advantages and disadvantages, too.

I chose the adjacency list because the runtime complexities for the operations I need
(adding and lookup) are faster than the other implementations.


## Section 4
###########################################################################

    (Please keep your answers brief and to-the-point.)

1. Describe any new tests you added and why you added them, or why you feel that your original
tests alone are sufficient.

I removed some tests due to spec changes that tested behavior that was prevented
by the precondition (@spec.requires). I felt that my original test suite was enough
because I didn't add any new methods and all the specifications of the methods were
covered.



2. Did you make any changes to your specifications as you were implementing your Graph? (yes/no)
If yes, describe your changes and why you made them.

For any method specifications I changed that involved throw, I either made them return
a boolean for if it was able to execute properly, or replaced it with a requires clause
instead. This is so I didn't have to handle exceptions that I created.

